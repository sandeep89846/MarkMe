

--- FILE: build.gradle.kts ---

plugins {
    alias(libs.plugins.android.application) apply false
    alias(libs.plugins.kotlin.android) apply false
    alias(libs.plugins.sqldelight) apply false
}

--- FILE: gradle.properties ---

# Project-wide Gradle settings.
# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.
# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. For more details, visit
# https://developer.android.com/r/tools/gradle-multi-project-decoupled-projects
# org.gradle.parallel=true
# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app's APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
# Kotlin code style for this project: "official" or "obsolete":
kotlin.code.style=official
# Enables namespacing of each library's R class so that its R class includes only the
# resources declared in the library itself and none from the library's dependencies,
# thereby reducing the size of the R class for that library
android.nonTransitiveRClass=true

--- FILE: local.properties ---

## This file is automatically generated by Android Studio.
# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
#
# This file should *NOT* be checked into Version Control Systems,
# as it contains information specific to your local configuration.
#
# Location of the SDK. This is only used by Gradle.
# For customization when using a Version Control System, please read the
# header note.
sdk.dir=C\:\\Users\\gontu\\AppData\\Local\\Android\\Sdk

--- FILE: settings.gradle.kts ---

pluginManagement {
    repositories {
        google {
            content {
                includeGroupByRegex("com\\.android.*")
                includeGroupByRegex("com\\.google.*")
                includeGroupByRegex("androidx.*")
            }
        }
        mavenCentral()
        gradlePluginPortal()
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}

rootProject.name = "ProjectMarkMe"
include(":app")
 

--- FILE: app/build.gradle.kts ---

plugins {
    alias(libs.plugins.android.application)
    alias(libs.plugins.kotlin.android)
    alias(libs.plugins.sqldelight)
}

android {
    namespace = "com.markme.app"
    compileSdk = 34

    defaultConfig {
        applicationId = "com.markme.app"
        minSdk = 26
        targetSdk = 34
        versionCode = 1
        versionName = "1.0"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }

    compileOptions {
        // REVERTED: Back to Java 8
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }

    kotlinOptions {
        // REVERTED: Back to Java 8
        jvmTarget = "1.8"
    }

    buildFeatures {
        compose = true
        buildConfig = true
    }

    composeOptions {
        kotlinCompilerExtensionVersion = libs.versions.kotlinComposeCompiler.get()
    }
}

sqldelight {
    databases {
        create("Database") {
            packageName.set("com.markme.data")
        }
    }
}

dependencies {
    // --- Core Android & Compose ---
    implementation(libs.androidx.core.ktx)
    implementation(libs.androidx.lifecycle.runtime.ktx)
    implementation(libs.androidx.activity.compose)
    implementation(libs.kotlinx.coroutines.android)


    implementation(libs.androidx.appcompat)
    implementation(libs.google.material)

    implementation(platform(libs.androidx.compose.bom))
    implementation(libs.androidx.ui)
    implementation(libs.androidx.ui.graphics)
    implementation(libs.androidx.ui.tooling.preview)
    implementation(libs.androidx.material3)


    // --- Networking ---
    implementation(libs.retrofit.main)
    implementation(libs.retrofit.converter.moshi)
    implementation(libs.okhttp.main)
    implementation(libs.okhttp.logging.interceptor)
    implementation(libs.moshi.kotlin)

    // --- Background Sync ---
    implementation(libs.androidx.workmanager)

    // --- Local Database ---
    implementation(libs.sqldelight.android.driver)
    implementation(libs.sqldelight.coroutines)

    // --- Security ---
    implementation(libs.androidx.biometric)
    implementation(libs.androidx.security.crypto)

    // --- Google Sign-In ---
    implementation(libs.play.services.auth)

    implementation(libs.play.services.location)

    // 2. ZXing (Zebra Crossing) for QR Scanning
    implementation(libs.zxing.android.embedded)

    // --- ViewModel for Compose ---
    implementation(libs.androidx.lifecycle.viewmodel.compose)
    implementation(libs.androidx.navigation.compose)

    // --- ADD THIS FOR ICONS ---
    implementation(libs.androidx.material.icons.extended)

    // --- Testing ---
    testImplementation(libs.junit)
    androidTestImplementation(libs.androidx.junit)
    androidTestImplementation(libs.androidx.espresso.core)
    androidTestImplementation(platform(libs.androidx.compose.bom))
    androidTestImplementation(libs.androidx.ui.test.junit4)
    debugImplementation(libs.androidx.ui.tooling)
    debugImplementation(libs.androidx.ui.test.manifest)
}

--- FILE: app/src/androidTest/java/com/markme/app/ExampleInstrumentedTest.kt ---

package com.markme.app

import androidx.test.platform.app.InstrumentationRegistry
import androidx.test.ext.junit.runners.AndroidJUnit4

import org.junit.Test
import org.junit.runner.RunWith

import org.junit.Assert.*

/**
 * Instrumented test, which will execute on an Android device.
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
@RunWith(AndroidJUnit4::class)
class ExampleInstrumentedTest {
    @Test
    fun useAppContext() {
        // Context of the app under test.
        val appContext = InstrumentationRegistry.getInstrumentation().targetContext
        assertEquals("com.markme.app", appContext.packageName)
    }
}

--- FILE: app/src/main/AndroidManifest.xml ---

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.USE_BIOMETRIC" />

    <uses-permission android:name="android.permission.CAMERA" />

    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />

    <application
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.ProjectMarkMe"
        tools:targetApi="31"
        android:networkSecurityConfig="@xml/network_security_config">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:label="@string/app_name"
            android:theme="@style/Theme.ProjectMarkMe">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <activity
            android:name="com.journeyapps.barcodescanner.CaptureActivity"
            android:screenOrientation="fullSensor"
            tools:replace="screenOrientation" />
    </application>

</manifest>

--- FILE: app/src/main/java/com/markme/app/MainActivity.kt ---

package com.markme.app

import android.content.Intent
import android.os.Bundle
import androidx.activity.compose.ManagedActivityResultLauncher
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge
import androidx.activity.result.ActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.activity.viewModels
import androidx.appcompat.app.AppCompatActivity
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
// --- START FIX ---
import androidx.compose.material.icons.automirrored.filled.ExitToApp // Use AutoMirrored
// --- END FIX ---
import androidx.compose.material.icons.filled.History
import androidx.compose.material.icons.filled.Home
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.ui.platform.LocalContext
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavHostController
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.currentBackStackEntryAsState
import androidx.navigation.compose.rememberNavController
import com.markme.app.ui.AuthUiState
import com.markme.app.ui.AuthViewModel
import com.markme.app.ui.HomeScreen
import com.markme.app.ui.HistoryScreen
import com.markme.app.ui.MainViewModel
import com.markme.app.ui.theme.ProjectMarkMeTheme

// Define navigation routes
sealed class Screen(val route: String, val label: String, val icon: ImageVector) {
    object Home : Screen("home", "Home", Icons.Default.Home)
    object History : Screen("history", "History", Icons.Default.History)
}

val navItems = listOf(Screen.Home, Screen.History)

class MainActivity : AppCompatActivity() {

    private val authViewModel: AuthViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()

        authViewModel.initialize(this.applicationContext)

        setContent {
            ProjectMarkMeTheme {
                val authState by authViewModel.uiState.collectAsState()

                // 1. Create Google Sign-In launcher
                val googleSignInLauncher = rememberLauncherForActivityResult(
                    contract = ActivityResultContracts.StartActivityForResult(),
                    onResult = { result ->
                        authViewModel.onSignInResult(result)
                    }
                )

                // 2. Show Auth screen or Main App
                if (authState.isAuthenticated) {
                    MainAppScreen(
                        onSignOut = {
                            authViewModel.signOut()
                        }
                    )
                } else {
                    AuthScreen(
                        uiState = authState,
                        onSignInClick = {
                            authViewModel.startSignIn(googleSignInLauncher)
                        }
                    )
                }
            }
        }
    }
}

@Composable
fun AuthScreen(uiState: AuthUiState, onSignInClick: () -> Unit) {
    Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding ->
        Column(
            modifier = Modifier
                .padding(innerPadding)
                .fillMaxSize()
                .padding(16.dp),
            verticalArrangement = Arrangement.Center,
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text(
                text = "Welcome to MarkMe",
                style = MaterialTheme.typography.headlineLarge
            )
            Spacer(modifier = Modifier.height(32.dp))

            if (uiState.isLoading) {
                CircularProgressIndicator()
                uiState.userMessage?.let {
                    Text(
                        text = it,
                        style = MaterialTheme.typography.bodyLarge,
                        textAlign = TextAlign.Center,
                        modifier = Modifier.padding(top = 16.dp)
                    )
                }
            } else {
                Button(onClick = onSignInClick, enabled = !uiState.isLoading) {
                    Text("Sign in with Google")
                }
                uiState.userMessage?.let {
                    Text(
                        text = it,
                        color = MaterialTheme.colorScheme.error,
                        style = MaterialTheme.typography.bodyLarge,
                        textAlign = TextAlign.Center,
                        modifier = Modifier.padding(top = 16.dp)
                    )
                }
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class) // Needed for TopAppBar
@Composable
fun MainAppScreen(onSignOut: () -> Unit) { // Add onSignOut parameter
    val navController = rememberNavController()
    val mainViewModel: MainViewModel = viewModel()

    // Initialize the ViewModel once
    val context = LocalContext.current
    LaunchedEffect(Unit) {
        mainViewModel.initialize(context)
    }

    Scaffold(
        modifier = Modifier.fillMaxSize(),
        topBar = {
            TopAppBar(
                title = { Text("Mark Me") },
                actions = {
                    IconButton(onClick = onSignOut) {
                        Icon(
                            // --- START FIX ---
                            imageVector = Icons.AutoMirrored.Filled.ExitToApp, // Use new icon
                            // --- END FIX ---
                            contentDescription = "Sign Out"
                        )
                    }
                }
            )
        },
        bottomBar = {
            NavigationBar {
                val navBackStackEntry by navController.currentBackStackEntryAsState()
                val currentRoute = navBackStackEntry?.destination?.route

                navItems.forEach { screen ->
                    NavigationBarItem(
                        icon = { Icon(screen.icon, contentDescription = screen.label) },
                        label = { Text(screen.label) },
                        selected = currentRoute == screen.route,
                        onClick = {
                            navController.navigate(screen.route) {
                                popUpTo(navController.graph.startDestinationRoute!!) {
                                    saveState = true
                                }
                                launchSingleTop = true
                                restoreState = true
                            }
                        }
                    )
                }
            }
        }
    ) { innerPadding ->
        AppNavHost(
            navController = navController,
            mainViewModel = mainViewModel,
            modifier = Modifier.padding(innerPadding) // This padding now respects the TopAppBar
        )
    }
}

// --- FIX: Removed the duplicate MainAppScreen() function that was here ---

@Composable
fun AppNavHost(
    navController: NavHostController,
    mainViewModel: MainViewModel,
    modifier: Modifier = Modifier
) {
    NavHost(
        navController = navController,
        startDestination = Screen.Home.route,
        modifier = modifier
    ) {
        composable(Screen.Home.route) {
            // Pass the singleton ViewModel to the home screen
            HomeScreen(mainViewModel = mainViewModel)
        }
        composable(Screen.History.route) {
            HistoryScreen()
        }
    }
}

--- FILE: app/src/main/java/com/markme/app/auth/EnrollmentManager.kt ---

package com.markme.app.auth

import android.content.Context
import android.os.Build
import android.security.keystore.KeyGenParameterSpec
import android.security.keystore.KeyProperties
import android.util.Base64
import android.util.Log
import androidx.appcompat.app.AppCompatActivity
import androidx.biometric.BiometricManager
import androidx.biometric.BiometricPrompt
import androidx.core.content.ContextCompat
import java.security.KeyPairGenerator
import java.security.KeyStore
import java.security.PrivateKey
import java.security.Signature
import java.security.InvalidAlgorithmParameterException
import java.util.concurrent.Executor

// A custom exception to make our error handling cleaner in the ViewModel
class NoBiometricException(message: String) : Exception(message)

object EnrollmentManager {

    private const val KEY_ALIAS = "com.markme.app.SIGNING_KEY"
    private const val ANDROID_KEYSTORE = "AndroidKeyStore"
    private const val TAG = "EnrollmentManager"

    fun isKeyEnrolled(): Boolean {
        return try {
            val keyStore = KeyStore.getInstance(ANDROID_KEYSTORE)
            keyStore.load(null)
            keyStore.containsAlias(KEY_ALIAS)
        } catch (e: Exception) {
            Log.e(TAG, "Failed to check key existence", e)
            false
        }
    }

    @Throws(NoBiometricException::class)
    fun createKeyAndGetPublicPem(): String {
        try {
            val kpg = KeyPairGenerator.getInstance(
                KeyProperties.KEY_ALGORITHM_EC,
                ANDROID_KEYSTORE
            )

            val spec = KeyGenParameterSpec.Builder(
                KEY_ALIAS,
                KeyProperties.PURPOSE_SIGN
            )
                .setAlgorithmParameterSpec(java.security.spec.ECGenParameterSpec("secp256r1"))
                .setDigests(KeyProperties.DIGEST_SHA256)
                .setUserAuthenticationRequired(true)
                .build()

            kpg.initialize(spec)
            val kp = kpg.generateKeyPair()
            val publicKey = kp.public

            val pubKeyBytes = publicKey.encoded
            val pubKeyBase64 = Base64.encodeToString(pubKeyBytes, Base64.NO_WRAP)
            return "-----BEGIN PUBLIC KEY-----\n$pubKeyBase64\n-----END PUBLIC KEY-----\n"

        } catch (e: InvalidAlgorithmParameterException) {
            Log.e(TAG, "Failed to create keypair, biometrics not enrolled?", e)
            throw NoBiometricException("Keyguard not set up. Please enroll a PIN, Pattern, or Fingerprint in your device's Security settings.")
        } catch (e: Exception) {
            Log.e(TAG, "Failed to create keypair", e)
            throw RuntimeException("Failed to create keypair", e)
        }
    }


    fun promptForBiometricSignature(
        activity: AppCompatActivity,
        onSuccess: (Signature) -> Unit,
        onFailure: (String) -> Unit
    ) {
        try {
            val keyStore = KeyStore.getInstance(ANDROID_KEYSTORE)
            keyStore.load(null)

            val privateKey = keyStore.getKey(KEY_ALIAS, null) as? PrivateKey
                ?: throw RuntimeException("Private key not found. Is device enrolled?")

            val signature = Signature.getInstance("SHA256withECDSA").apply {
                initSign(privateKey)
            }

            val executor = ContextCompat.getMainExecutor(activity)
            val promptInfo = BiometricPrompt.PromptInfo.Builder()
                .setTitle("Confirm Attendance")
                .setSubtitle("Authenticate to sign your attendance record")
                // --- START FIX ---
                // .setNegativeButtonText("Cancel") // <-- REMOVE THIS LINE
                // --- END FIX ---
                .setAllowedAuthenticators(BiometricManager.Authenticators.BIOMETRIC_STRONG or BiometricManager.Authenticators.DEVICE_CREDENTIAL)
                .build()

            val callback = object : BiometricPrompt.AuthenticationCallback() {
                override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {
                    super.onAuthenticationSucceeded(result)
                    val cryptoObject = result.cryptoObject
                    if (cryptoObject?.signature != null) {
                        onSuccess(cryptoObject.signature!!)
                    } else {
                        onFailure("Authentication succeeded but signature object was null.")
                    }
                }

                override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {
                    super.onAuthenticationError(errorCode, errString)
                    Log.e(TAG, "Auth error: $errorCode - $errString")
                    onFailure("Authentication error: $errString")
                }

                override fun onAuthenticationFailed() {
                    super.onAuthenticationFailed()
                    Log.w(TAG, "Authentication failed (e.g., wrong finger).")
                }
            }

            BiometricPrompt(activity as androidx.fragment.app.FragmentActivity, executor, callback)
                .authenticate(promptInfo, BiometricPrompt.CryptoObject(signature))

        } catch (e: Exception) {
            Log.e(TAG, "Biometric prompt failed to start", e)
            onFailure("Biometric error: ${e.message}")
        }
    }
}

--- FILE: app/src/main/java/com/markme/app/data/DatabaseManager.kt ---

package com.markme.app.data

import android.content.Context
import app.cash.sqldelight.driver.android.AndroidSqliteDriver
import com.markme.data.Database // <-- This import is auto-generated by SQLDelight

// --- START FIX ---
// Convert DatabaseManager from a class to an object to make it a singleton
object DatabaseManager {

    private var databaseInstance: Database? = null

    /**
     * Creates (if necessary) and returns the singleton Database instance.
     *
     * @param context An application context is required to create the driver
     * on first call.
     * @return The singleton Database instance.
     */
    fun getInstance(context: Context): Database {
        // Use standard double-check locking for thread-safety
        return databaseInstance ?: synchronized(this) {
            databaseInstance ?: buildDatabase(context).also {
                databaseInstance = it
            }
        }
    }

    private fun buildDatabase(context: Context): Database {
        val driver = AndroidSqliteDriver(
            schema = Database.Schema, // <-- This is from the import
            context = context.applicationContext, // Use application context
            name = "MarkMe.db"
        )
        return Database(driver) // <-- This is from the import
    }
}
// --- END FIX ---

--- FILE: app/src/main/java/com/markme/app/network/ApiService.kt ---

package com.markme.app.network

import retrofit2.http.Body
import retrofit2.http.GET
import retrofit2.http.Header
import retrofit2.http.POST
import retrofit2.http.Query

// --- Data Classes for API Communication ---

data class TimeResponse(val utc: String)

// --- START NEW AUTH CLASSES ---
// For POST /api/auth/google-signin
data class GoogleSignInRequest(
    val idToken: String,
    val deviceId: String,
    val pubkeyPem: String
)
data class AuthResponse(val token: String, val status: String)
// --- END NEW AUTH CLASSES ---

// For GET /api/session/current
data class LocationData(val latitude: Double, val longitude: Double)
data class SessionInfoResponse(
    val sessionId: String,
    val className: String,
    val location: LocationData,
    val qrRotationIntervalMs: Long
)

// For data parsed from the QR code
data class QrNonceResponse(
    val qrNonce: String,
    val sessionId: String,
    val ts: String
)

// For POST /api/attendance/batch
data class AttendanceEvent(
    val attendance: Map<String, Any>,
    val student_sig: String
)
data class AttendanceBatch(val events: List<AttendanceEvent>)
data class BatchResultItem(val id: String, val status: String, val metadata: String?)
data class AttendanceBatchResponse(
    val results: List<BatchResultItem>,
    val server_time: String
)

// --- START NEW HISTORY CLASSES ---
data class Subject(
    val id: String,
    val code: String,
    val name: String
)
data class SubjectsResponse(val subjects: List<Subject>)

data class AttendanceHistoryItem(
    val id: String,
    val className: String,
    val status: String,
    val timestamp: String // ISO 8601 string
)
data class HistoryResponse(val history: List<AttendanceHistoryItem>)
// --- END NEW HISTORY CLASSES ---


// --- The Retrofit API Interface ---
interface ApiService {

    @GET("api/time")
    suspend fun getServerTime(): TimeResponse

    // --- START UPDATED/NEW ENDPOINTS ---
    @POST("api/auth/google-signin")
    suspend fun googleSignIn(@Body req: GoogleSignInRequest): AuthResponse

    @GET("api/session/current")
    suspend fun getCurrentSession(
        @Header("Authorization") token: String
    ): SessionInfoResponse

    @GET("api/student/my-subjects")
    suspend fun getMySubjects(
        @Header("Authorization") token: String
    ): SubjectsResponse

    @GET("api/student/my-history")
    suspend fun getMyHistory(
        @Header("Authorization") token: String,
        @Query("subjectId") subjectId: String
    ): HistoryResponse
    // --- END UPDATED/NEW ENDPOINTS ---

    @POST("api/attendance/batch")
    suspend fun postAttendanceBatch(
        @Header("Authorization") token: String,
        @Body batch: AttendanceBatch
    ): AttendanceBatchResponse
}

--- FILE: app/src/main/java/com/markme/app/network/RetrofitClient.kt ---

package com.markme.app.network

import com.markme.app.BuildConfig
import com.squareup.moshi.Moshi // <-- Make sure this is imported
import com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory // <-- Make sure this is imported
import okhttp3.OkHttpClient
import okhttp3.logging.HttpLoggingInterceptor
import retrofit2.Retrofit
import retrofit2.converter.moshi.MoshiConverterFactory

object RetrofitClient {

    private const val DEV_BASE_URL = "https://kangaroo-ultimate-correctly.ngrok-free.app/"
    private const val PROD_BASE_URL = "http://your-production-server.com/"

    // --- START FIX ---
    // Make this 'val' (public) instead of 'private val'
    val moshi: Moshi = Moshi.Builder()
        .add(KotlinJsonAdapterFactory()) // This is the adapter that fixes the crash
        .build()
    // --- END FIX ---

    private val loggingInterceptor = HttpLoggingInterceptor().apply {
        level = HttpLoggingInterceptor.Level.BODY
    }

    private val okHttpClient = OkHttpClient.Builder()
        .addInterceptor(loggingInterceptor)
        .build()

    val instance: ApiService by lazy {
        Retrofit.Builder()
            .baseUrl(DEV_BASE_URL)
            .client(okHttpClient)
            .addConverterFactory(MoshiConverterFactory.create(moshi)) // Uses our correct instance
            .build()
            .create(ApiService::class.java)
    }
}

--- FILE: app/src/main/java/com/markme/app/sync/AttendanceWorker.kt ---

package com.markme.app.sync

import android.content.Context
import android.content.Intent
import android.util.Log
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import com.markme.app.data.DatabaseManager
import com.markme.app.network.ApiService
import com.markme.app.network.AttendanceBatch
import com.markme.app.network.AttendanceEvent
import com.markme.app.network.RetrofitClient
import com.markme.data.PendingAttendanceQueries
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.json.JSONObject

/**
 * Worker that uploads pending attendance records.
 * On success ("ok"), it moves the record to the local VerifiedAttendance table for offline history.
 */
class AttendanceWorker(
    private val context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {

    companion object {
        private const val TAG = "AttendanceWorker"
        const val INPUT_AUTH_TOKEN = "AUTH_TOKEN"
        const val BATCH_SIZE = 20
        const val ACTION_ATTENDANCE_SYNCED = "com.markme.app.ACTION_ATTENDANCE_SYNCED"
    }

    private val dbQueries: PendingAttendanceQueries
    private val api: ApiService

    init {
        dbQueries = DatabaseManager.getInstance(context).pendingAttendanceQueries
        api = RetrofitClient.instance
    }

    override suspend fun doWork(): Result = withContext(Dispatchers.IO) {
        val token = inputData.getString(INPUT_AUTH_TOKEN)
        if (token.isNullOrBlank()) {
            Log.e(TAG, "Auth token is missing. Stopping worker.")
            return@withContext Result.failure()
        }

        val authHeader = "Bearer $token"

        // Fetch pending records from SQLDelight
        val pendingRecords = try {
            dbQueries.getPending(limit = BATCH_SIZE.toLong()).executeAsList()
        } catch (e: Exception) {
            Log.e(TAG, "Failed to read pending records from DB", e)
            return@withContext Result.retry()
        }

        if (pendingRecords.isEmpty()) {
            return@withContext Result.success()
        }

        val recordIds = pendingRecords.map { it.id }

        try {
            dbQueries.markAsSyncing(recordIds)
        } catch (e: Exception) {
            Log.w(TAG, "Failed to mark records as SYNCING; continuing", e)
        }

        val events = pendingRecords.map { record ->
            AttendanceEvent(
                attendance = jsonToMap(record.attendance_blob),
                student_sig = record.student_sig
            )
        }

        val batchRequest = AttendanceBatch(events = events)

        try {
            val response = api.postAttendanceBatch(authHeader, batchRequest)

            var anyDeleted = false
            var hasTransientError = false
            var hasFatalError = false

            response.results.forEach { result ->
                // We need the original record to get metadata (className, timestamp) to save to history
                val originalRecord = pendingRecords.find { it.id == result.id }

                when (result.status) {
                    "ok" -> {
                        try {
                            // 1. Delete from Pending Queue
                            dbQueries.deleteById(result.id)

                            // 2. Insert into Verified History (NEW FEATURE)
                            if (originalRecord != null) {
                                dbQueries.insertVerified(
                                    id = result.id,
                                    sessionId = originalRecord.sess,
                                    className = originalRecord.className,
                                    status = "VERIFIED",
                                    timestamp = originalRecord.created_at,
                                    subjectId = null // We don't strictly know subjectId here, but that's okay
                                )
                            }

                            Log.i(TAG, "Successfully synced and moved to history: ${result.id}")
                            anyDeleted = true
                        } catch (e: Exception) {
                            Log.w(TAG, "Failed to update DB for: ${result.id}", e)
                            hasTransientError = true
                        }
                    }

                    // Fatal errors - stop retrying
                    "bad_signature", "unauthorized_device", "invalid_payload",
                    "unknown_session", "device_mismatch", "location_mismatch",
                    "nonce_missing", "nonce_time_mismatch" -> {
                        try {
                            dbQueries.markAsFailed(listOf(result.id))
                        } catch (e: Exception) {}
                        hasFatalError = true
                        Log.e(TAG, "Fatal sync error for ${result.id}: ${result.status}")
                    }

                    else -> {
                        try {
                            dbQueries.markAsFailed(listOf(result.id))
                        } catch (e: Exception) {}
                        hasTransientError = true
                    }
                }
            }

            // Broadcast so HistoryScreen refreshes
            if (anyDeleted) {
                try {
                    val intent = Intent(ACTION_ATTENDANCE_SYNCED)
                    context.sendBroadcast(intent)
                } catch (e: Exception) {}
            }

            return@withContext when {
                hasFatalError -> Result.failure()
                hasTransientError -> Result.retry()
                else -> Result.success()
            }
        } catch (e: Exception) {
            Log.e(TAG, "Network error during sync", e)
            try {
                dbQueries.markAsFailed(recordIds)
            } catch (ex: Exception) {}
            return@withContext Result.retry()
        }
    }

    private fun jsonToMap(jsonString: String): Map<String, Any> {
        val map = mutableMapOf<String, Any>()
        try {
            val obj = JSONObject(jsonString)
            val keys = obj.keys()
            while (keys.hasNext()) {
                val k = keys.next()
                val v = obj.get(k)
                map[k] = when (v) {
                    is Number -> v
                    is Boolean -> v
                    else -> v.toString()
                }
            }
        } catch (e: Exception) {
            Log.w(TAG, "Failed to parse JSON", e)
        }
        return map
    }
}

--- FILE: app/src/main/java/com/markme/app/ui/AuthViewModel.kt ---

package com.markme.app.ui

import android.content.Context
import android.content.Intent
import android.util.Log
import androidx.activity.compose.ManagedActivityResultLauncher
import androidx.activity.result.ActivityResult
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.google.android.gms.auth.api.signin.GoogleSignIn
import com.google.android.gms.auth.api.signin.GoogleSignInAccount
import com.google.android.gms.auth.api.signin.GoogleSignInClient
import com.google.android.gms.auth.api.signin.GoogleSignInOptions
import com.google.android.gms.common.api.ApiException
import com.google.android.gms.tasks.Task
import com.markme.app.auth.EnrollmentManager
import com.markme.app.auth.NoBiometricException
import com.markme.app.network.ApiService
import com.markme.app.network.GoogleSignInRequest
import com.markme.app.network.RetrofitClient
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.util.UUID

data class AuthUiState(
    val isLoading: Boolean = false,
    val userMessage: String? = null,
    val isAuthenticated: Boolean = false
)

class AuthViewModel : ViewModel() {

    private val _uiState = MutableStateFlow(AuthUiState())
    val uiState = _uiState.asStateFlow()

    private lateinit var api: ApiService
    private lateinit var googleSignInClient: GoogleSignInClient
    private lateinit var appContext: Context

    // This is the variable declaration
    private var deviceId: String? = null

    // TODO: Get this from your Google Cloud Console / strings.xml
    private val WEB_CLIENT_ID = "785046225223-9pvc27uun2ol3rrpa7sclj8jenbrg2l6.apps.googleusercontent.com"

    fun initialize(context: Context) {
        this.appContext = context.applicationContext
        api = RetrofitClient.instance

        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)
            .requestIdToken(WEB_CLIENT_ID)
            .requestEmail()
            .build()
        googleSignInClient = GoogleSignIn.getClient(appContext, gso)

        checkIfAlreadyAuthenticated()
    }

    private fun checkIfAlreadyAuthenticated() {
        val prefs = appContext.getSharedPreferences("MarkMePrefs", Context.MODE_PRIVATE)
        val token = prefs.getString("SESSION_TOKEN", null)
        val storedDeviceId = prefs.getString("DEVICE_ID", null)

        if (token != null && storedDeviceId != null && EnrollmentManager.isKeyEnrolled()) {
            this.deviceId = storedDeviceId
            _uiState.update { it.copy(isAuthenticated = true) }
        } else {
            // Not fully enrolled, ensure we're signed out
            googleSignInClient.signOut()
            _uiState.update { it.copy(isLoading = false, userMessage = "Please sign in.") }
        }
    }

    fun startSignIn(launcher: ManagedActivityResultLauncher<Intent, ActivityResult>) {
        _uiState.update { it.copy(isLoading = true) }
        val signInIntent = googleSignInClient.signInIntent
        launcher.launch(signInIntent)
    }

    fun onSignInResult(result: ActivityResult) {
        try {
            val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)
            val account = task.getResult(ApiException::class.java)
            if (account?.idToken != null) {
                Log.i("AuthViewModel", "Google Sign-In Success. Got idToken.")
                enrollDevice(account.idToken!!)
            } else {
                _uiState.update { it.copy(isLoading = false, userMessage = "Sign-in failed: No ID Token.") }
            }
        } catch (e: ApiException) {
            Log.e("AuthViewModel", "Google Sign-In failed", e)
            _uiState.update { it.copy(isLoading = false, userMessage = "Sign-in failed: ${e.statusCode}") }
        }
    }

    private fun enrollDevice(idToken: String) {
        viewModelScope.launch(Dispatchers.IO) {
            _uiState.update { it.copy(isLoading = true, userMessage = "Enrolling secure key...") }
            try {
                // 1. Generate secure key
                val pubKeyPem = EnrollmentManager.createKeyAndGetPublicPem()

                // 2. Get or create device ID
                val prefs = appContext.getSharedPreferences("MarkMePrefs", Context.MODE_PRIVATE)
                var storedDeviceId = prefs.getString("DEVICE_ID", null)
                if (storedDeviceId == null) {
                    storedDeviceId = "dev-${UUID.randomUUID()}"
                    prefs.edit().putString("DEVICE_ID", storedDeviceId).apply()
                }
                // This line (115) is now valid because the variable is declared above
                deviceId = storedDeviceId

                // 3. Call new server endpoint
                _uiState.update { it.copy(userMessage = "Registering device with server...") }
                val request = GoogleSignInRequest(
                    idToken = idToken,
                    deviceId = storedDeviceId,
                    pubkeyPem = pubKeyPem
                )
                val response = api.googleSignIn(request)

                // 4. Save session token
                prefs.edit().putString("SESSION_TOKEN", response.token).apply()
                Log.i("AuthViewModel", "Enrollment complete. Stored session token.")

                _uiState.update {
                    it.copy(
                        isLoading = false,
                        userMessage = null,
                        isAuthenticated = true
                    )
                }

            } catch (e: NoBiometricException) {
                Log.e("AuthViewModel", "Enrollment failed: No biometrics.", e)
                _uiState.update { it.copy(isLoading = false, userMessage = "Enrollment Failed: Please enroll a Fingerprint or PIN and restart the app.") }
                googleSignInClient.signOut() // Sign out so they can retry
            } catch (e: Exception) {
                Log.e("AuthViewModel", "Enrollment failed", e)
                _uiState.update { it.copy(isLoading = false, userMessage = "Enrollment failed: ${e.message}") }
                googleSignInClient.signOut() // Sign out so they can retry
            }
        }
    }

    fun signOut() {
        viewModelScope.launch(Dispatchers.IO) {
            // 1. Sign out from Google
            googleSignInClient.signOut()

            // 2. Clear local preferences
            val prefs = appContext.getSharedPreferences("MarkMePrefs", Context.MODE_PRIVATE)
            prefs.edit().clear().apply()

            // 3. Update UI state to show AuthScreen
            _uiState.update {
                it.copy(
                    isAuthenticated = false,
                    userMessage = "You have been signed out."
                )
            }
        }
    }
}

--- FILE: app/src/main/java/com/markme/app/ui/HistoryScreen.kt ---

package com.markme.app.ui

import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.animateContentSize // <--- ADDED THIS IMPORT
import androidx.compose.animation.core.Spring
import androidx.compose.animation.core.spring
import androidx.compose.animation.expandVertically
import androidx.compose.animation.fadeIn
import androidx.compose.animation.fadeOut
import androidx.compose.animation.shrinkVertically
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.KeyboardArrowDown
import androidx.compose.material.icons.filled.KeyboardArrowUp
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.markme.app.network.AttendanceHistoryItem
import com.markme.app.network.Subject
import java.time.Instant
import java.time.ZoneId
import java.time.format.DateTimeFormatter

@Composable
fun HistoryScreen(
    modifier: Modifier = Modifier,
    historyViewModel: HistoryViewModel = viewModel()
) {
    val context = LocalContext.current
    LaunchedEffect(Unit) {
        historyViewModel.initialize(context)
    }

    val uiState by historyViewModel.uiState.collectAsState()

    Column(
        modifier = modifier
            .fillMaxSize()
            .background(MaterialTheme.colorScheme.surface)
            .padding(16.dp)
    ) {
        Text(
            text = "Attendance History",
            style = MaterialTheme.typography.headlineMedium,
            fontWeight = FontWeight.Bold,
            color = MaterialTheme.colorScheme.onSurface,
            modifier = Modifier.padding(bottom = 16.dp)
        )

        if (uiState.subjects.isEmpty() && uiState.isLoading) {
            Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                CircularProgressIndicator()
            }
        } else if (uiState.subjects.isEmpty() && uiState.userMessage != null) {
            Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                Text(
                    text = uiState.userMessage ?: "No subjects found.",
                    color = MaterialTheme.colorScheme.error
                )
            }
        } else {
            LazyColumn(
                verticalArrangement = Arrangement.spacedBy(8.dp),
                modifier = Modifier.fillMaxSize()
            ) {
                items(uiState.subjects) { subject ->
                    ExpandableSubjectCard(
                        subject = subject,
                        isExpanded = uiState.selectedSubject?.id == subject.id,
                        onCardClick = { historyViewModel.toggleSubjectSelection(subject) },
                        isLoading = uiState.isLoading,
                        historyItems = if (uiState.selectedSubject?.id == subject.id) uiState.attendanceHistory else emptyList()
                    )
                }

                item { Spacer(modifier = Modifier.height(80.dp)) }
            }
        }
    }
}

@Composable
fun ExpandableSubjectCard(
    subject: Subject,
    isExpanded: Boolean,
    onCardClick: () -> Unit,
    isLoading: Boolean,
    historyItems: List<AttendanceHistoryItem>
) {
    val containerColor = if (isExpanded)
        MaterialTheme.colorScheme.primaryContainer
    else
        MaterialTheme.colorScheme.surfaceContainerHigh

    val contentColor = if (isExpanded)
        MaterialTheme.colorScheme.onPrimaryContainer
    else
        MaterialTheme.colorScheme.onSurface

    Card(
        shape = RoundedCornerShape(12.dp),
        colors = CardDefaults.cardColors(containerColor = containerColor),
        elevation = CardDefaults.cardElevation(defaultElevation = if (isExpanded) 4.dp else 1.dp),
        modifier = Modifier
            .fillMaxWidth()
            .animateContentSize(
                animationSpec = spring(
                    dampingRatio = Spring.DampingRatioLowBouncy,
                    stiffness = Spring.StiffnessLow
                )
            )
    ) {
        Column {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .clickable { onCardClick() }
                    .padding(16.dp),
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Column(modifier = Modifier.weight(1f)) {
                    Text(
                        text = subject.name,
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold,
                        color = contentColor
                    )
                    Text(
                        text = subject.code,
                        style = MaterialTheme.typography.bodySmall,
                        color = contentColor.copy(alpha = 0.7f)
                    )
                }

                Icon(
                    imageVector = if (isExpanded) Icons.Default.KeyboardArrowUp else Icons.Default.KeyboardArrowDown,
                    contentDescription = if (isExpanded) "Collapse" else "Expand",
                    tint = contentColor
                )
            }

            if (isExpanded) {
                HorizontalDivider(
                    color = contentColor.copy(alpha = 0.2f),
                    thickness = 1.dp,
                    modifier = Modifier.padding(horizontal = 16.dp)
                )

                Column(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp)
                ) {
                    if (isLoading && historyItems.isEmpty()) {
                        Box(modifier = Modifier.fillMaxWidth(), contentAlignment = Alignment.Center) {
                            CircularProgressIndicator(
                                modifier = Modifier.size(24.dp),
                                color = contentColor
                            )
                        }
                    } else if (historyItems.isEmpty()) {
                        Text(
                            text = "No attendance history available.",
                            style = MaterialTheme.typography.bodyMedium,
                            color = contentColor.copy(alpha = 0.7f),
                            modifier = Modifier.padding(vertical = 8.dp)
                        )
                    } else {
                        historyItems.forEach { record ->
                            HistoryRowItem(record, contentColor)
                            Spacer(modifier = Modifier.height(8.dp))
                        }
                    }
                }
            }
        }
    }
}

@Composable
fun HistoryRowItem(record: AttendanceHistoryItem, parentContentColor: Color) {
    val instant = try {
        Instant.parse(record.timestamp)
    } catch (e: Exception) { Instant.now() }

    val formatter = DateTimeFormatter.ofPattern("MMM dd, hh:mm a")
        .withZone(ZoneId.systemDefault())
    val formattedDate = formatter.format(instant)

    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clip(RoundedCornerShape(8.dp))
            .background(MaterialTheme.colorScheme.surface.copy(alpha = 0.5f))
            .padding(12.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Column(modifier = Modifier.weight(1f)) {
            Text(
                text = formattedDate,
                style = MaterialTheme.typography.bodyMedium,
                fontWeight = FontWeight.SemiBold,
                color = MaterialTheme.colorScheme.onSurface
            )
            Text(
                text = "Status: ${record.status}",
                style = MaterialTheme.typography.bodySmall,
                color = if (record.status == "VERIFIED") Color(0xFF1B5E20) else MaterialTheme.colorScheme.error
            )
        }
    }
}

--- FILE: app/src/main/java/com/markme/app/ui/HistoryViewModel.kt ---

package com.markme.app.ui

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.markme.app.data.DatabaseManager
import com.markme.app.network.ApiService
import com.markme.app.network.AttendanceHistoryItem
import com.markme.app.network.RetrofitClient
import com.markme.app.network.Subject
import com.markme.data.PendingAttendanceQueries
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch

data class HistoryUiState(
    val isLoading: Boolean = false,
    val userMessage: String? = null,
    val subjects: List<Subject> = emptyList(),
    val selectedSubject: Subject? = null,
    val attendanceHistory: List<AttendanceHistoryItem> = emptyList()
)

class HistoryViewModel : ViewModel() {

    companion object {
        const val TAG = "HistoryViewModel"
        const val ACTION_ATTENDANCE_SYNCED = "com.markme.app.ACTION_ATTENDANCE_SYNCED"
    }

    private val _uiState = MutableStateFlow(HistoryUiState())
    val uiState = _uiState.asStateFlow()

    private lateinit var api: ApiService
    private lateinit var dbQueries: PendingAttendanceQueries
    private var sessionToken: String? = null
    private var appContext: Context? = null
    private var syncBroadcastReceiver: BroadcastReceiver? = null

    fun initialize(context: Context) {
        api = RetrofitClient.instance
        dbQueries = DatabaseManager.getInstance(context).pendingAttendanceQueries

        val prefs = context.getSharedPreferences("MarkMePrefs", Context.MODE_PRIVATE)
        this.sessionToken = prefs.getString("SESSION_TOKEN", null)
        this.appContext = context.applicationContext

        loadCachedSubjects()
        fetchSubjects()

        try {
            val filter = IntentFilter(ACTION_ATTENDANCE_SYNCED)
            syncBroadcastReceiver = object : BroadcastReceiver() {
                override fun onReceive(ctx: Context?, intent: Intent?) {
                    val selected = _uiState.value.selectedSubject
                    selected?.let {
                        fetchHistoryForSubject(it, forceReload = true)
                    }
                }
            }
            appContext?.registerReceiver(syncBroadcastReceiver, filter)
        } catch (e: Exception) {
            Log.w(TAG, "Failed to register receiver", e)
        }
    }

    private fun loadCachedSubjects() {
        viewModelScope.launch(Dispatchers.IO) {
            val cached = dbQueries.getAllSubjects().executeAsList()
            if (cached.isNotEmpty()) {
                val subjects = cached.map { Subject(it.id, it.code, it.name) }
                _uiState.update { it.copy(subjects = subjects) }
            }
        }
    }

    fun fetchSubjects() {
        if (sessionToken == null) return
        viewModelScope.launch(Dispatchers.IO) {
            try {
                val response = api.getMySubjects("Bearer $sessionToken")

                dbQueries.transaction {
                    dbQueries.deleteAllSubjects()
                    response.subjects.forEach {
                        dbQueries.insertSubject(it.id, it.code, it.name)
                    }
                }

                _uiState.update {
                    it.copy(subjects = response.subjects, userMessage = null)
                }
            } catch (e: Exception) {
                Log.e(TAG, "Failed to fetch subjects from network", e)
                if (_uiState.value.subjects.isEmpty()) {
                    _uiState.update { it.copy(userMessage = "Offline mode: No subjects found.") }
                }
            }
        }
    }

    // --- THIS IS THE METHOD YOU WERE MISSING ---
    fun toggleSubjectSelection(subject: Subject) {
        if (_uiState.value.selectedSubject?.id == subject.id) {
            // If clicking the already open subject, close it
            _uiState.update { it.copy(selectedSubject = null, attendanceHistory = emptyList()) }
        } else {
            // Otherwise, fetch and open the new one
            fetchHistoryForSubject(subject)
        }
    }
    // -------------------------------------------

    fun fetchHistoryForSubject(subject: Subject, forceReload: Boolean = false) {
        if (!forceReload && subject.id == _uiState.value.selectedSubject?.id) {
            return
        }

        viewModelScope.launch(Dispatchers.IO) {
            _uiState.update {
                it.copy(isLoading = true, selectedSubject = subject, userMessage = null)
            }

            val cachedRecords = dbQueries.getVerifiedBySubject(subject.id).executeAsList()
            val historyItems = cachedRecords.map {
                AttendanceHistoryItem(it.id, it.className, it.status, it.timestamp)
            }
            _uiState.update { it.copy(attendanceHistory = historyItems) }

            if (sessionToken == null) {
                _uiState.update { it.copy(isLoading = false) }
                return@launch
            }

            try {
                val response = api.getMyHistory("Bearer $sessionToken", subject.id)

                dbQueries.transaction {
                    response.history.forEach { record ->
                        dbQueries.insertVerified(
                            id = record.id,
                            sessionId = "unknown",
                            className = record.className,
                            status = record.status,
                            timestamp = record.timestamp,
                            subjectId = subject.id
                        )
                    }
                }

                _uiState.update {
                    it.copy(isLoading = false, attendanceHistory = response.history)
                }
            } catch (e: Exception) {
                Log.e(TAG, "Failed to fetch history from network", e)
                _uiState.update {
                    it.copy(isLoading = false, userMessage = "Showing offline history.")
                }
            }
        }
    }

    override fun onCleared() {
        super.onCleared()
        try {
            syncBroadcastReceiver?.let { appContext?.unregisterReceiver(it) }
        } catch (e: Exception) {}
    }
}

--- FILE: app/src/main/java/com/markme/app/ui/HomeScreen.kt ---

package com.markme.app.ui

import android.Manifest
import androidx.activity.compose.ManagedActivityResultLauncher
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.Button
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.journeyapps.barcodescanner.ScanContract
import com.journeyapps.barcodescanner.ScanOptions
import com.markme.data.PendingAttendance
import java.time.Instant
import java.time.ZoneId
import java.time.format.DateTimeFormatter

@Composable
fun HomeScreen(
    modifier: Modifier = Modifier,
    mainViewModel: MainViewModel = viewModel()
) {
    val activity = LocalContext.current as AppCompatActivity
    val uiState by mainViewModel.uiState.collectAsState()

    val qrScannerLauncher = rememberLauncherForActivityResult(
        contract = ScanContract(),
        onResult = { result ->
            mainViewModel.onQrCodeScanned(result.contents)
        }
    )

    val locationPermissionLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestPermission(),
        onResult = { isGranted ->
            if (isGranted) {
                mainViewModel.onMarkAttendanceClicked()
            }
        }
    )

    MarkMeAppScreen(
        uiState = uiState,
        onMarkAttendanceClick = {
            locationPermissionLauncher.launch(Manifest.permission.ACCESS_FINE_LOCATION)
        },
        onScanQrClick = {
            mainViewModel.onScanQrClicked()
        },
        onSignClick = {
            mainViewModel.onSignClicked(activity)
        },
        onRetryClick = {
            mainViewModel.retryFetchSession()
        },
        qrScannerLauncher = qrScannerLauncher,
        modifier = modifier
    )
}


@Composable
fun MarkMeAppScreen(
    uiState: HomeUiState,
    onMarkAttendanceClick: () -> Unit,
    onScanQrClick: () -> Unit,
    onSignClick: () -> Unit,
    onRetryClick: () -> Unit,
    qrScannerLauncher: ManagedActivityResultLauncher<ScanOptions, *>,
    modifier: Modifier = Modifier
) {

    if (uiState.userMessage?.contains("Please scan the QR code") == true) {
        val scanOptions = ScanOptions()
            .setPrompt("Scan the class QR code")
            .setBeepEnabled(true)
            .setOrientationLocked(true)
            .setDesiredBarcodeFormats(ScanOptions.QR_CODE)

        qrScannerLauncher.launch(scanOptions)
    }

    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        // --- MODIFICATION: Use padding to account for TopAppBar ---
        // Text(
        //     text = "Project: MarkMe",
        //     style = MaterialTheme.typography.headlineMedium,
        //     modifier = Modifier.padding(top = 32.dp)
        // )
        // --- END MODIFICATION ---

        uiState.currentSession?.let {
            Text(
                text = "Current Class: ${it.className}",
                style = MaterialTheme.typography.bodyLarge,
                modifier = Modifier.padding(top = 8.dp)
            )
        }

        Spacer(modifier = Modifier.height(24.dp))

        val hasMarkedToday = uiState.attendanceHistory.any {
            it.sess == uiState.currentSession?.sessionId &&
                    (it.status == "PENDING" ||
                            it.status == "SYNCING" || it.status == "VERIFIED" ||
                            it.status == "SYNCED" || it.status == "FAILED") // <-- ADD SYNCED AND FAILED
        }

        // 1. Handle loading and button states
        if (uiState.isLoading) {
            // State 1: App is loading (enrolling, syncing time, etc.)
            CircularProgressIndicator(modifier = Modifier.padding(vertical = 16.dp))
            Text(
                text = uiState.userMessage ?: "Loading...",
                style = MaterialTheme.typography.bodyLarge,
                textAlign = TextAlign.Center,
                modifier = Modifier.padding(vertical = 24.dp)
            )
        } else if (uiState.currentSession == null) {
            // State 2: No session
            Text(
                text = "Status: ${uiState.userMessage}",
                style = MaterialTheme.typography.bodyLarge.copy(color = MaterialTheme.colorScheme.onSurfaceVariant),
                textAlign = TextAlign.Center,
                modifier = Modifier.padding(vertical = 24.dp)
            )
            Button(onClick = onRetryClick) {
                Text("RETRY")
            }
        } else if (hasMarkedToday) {
            // State 3: Already Marked
            Button(onClick = {}, enabled = false) {
                Text("ATTENDANCE ALREADY MARKED")
            }
        } else if (uiState.isMarking && uiState.userMessage?.contains("Show teacher") == true) {
            // State 4: Got location, waiting for teacher
            Text(
                text = "Status: ${uiState.userMessage}", // "Show teacher: 26.250, 78.169"
                style = MaterialTheme.typography.bodyLarge.copy(fontWeight = FontWeight.Bold),
                textAlign = TextAlign.Center,
                modifier = Modifier.padding(vertical = 24.dp)
            )
            Button(onClick = onScanQrClick) {
                Text("TEACHER HAS ENTERED, SCAN QR")
            }
        } else if (uiState.isMarking && uiState.userMessage?.contains("QR Code Scanned") == true) {
            // State 5: Scanned QR, waiting for sign
            Text(
                text = "Status: ${uiState.userMessage}", // "QR Code Scanned. Tap 'Sign'."
                style = MaterialTheme.typography.bodyLarge.copy(color = Color(0xFF1B5E20)), // Dark Green
                textAlign = TextAlign.Center,
                modifier = Modifier.padding(vertical = 24.dp)
            )
            Button(onClick = onSignClick) {
                Text("SIGN ATTENDANCE")
            }
        }
        else {
            // State 6: Enrolled and Idle
            Button(onClick = onMarkAttendanceClick) {
                Text("MARK ATTENDANCE")
            }
        }

        // Show the user message (e.g., "SUCCESS!")
        if(uiState.userMessage?.contains("SUCCESS") == true) {
            Text(
                text = uiState.userMessage,
                style = MaterialTheme.typography.bodyMedium.copy(color = Color(0xFF1B5E20)),
                textAlign = TextAlign.Center,
                modifier = Modifier.padding(top = 16.dp)
            )
        }

        // 2. Handle Local Attendance History
        Spacer(modifier = Modifier.height(32.dp))
        Text(
            text = "Local Sync Queue",
            style = MaterialTheme.typography.titleMedium,
        )
        HorizontalDivider(modifier = Modifier.padding(vertical = 8.dp))

        LazyColumn(modifier = Modifier.fillMaxSize()) {
            items(uiState.attendanceHistory) { record ->
                AttendanceHistoryItem(record = record)
            }
        }
    }
}

@Composable
fun AttendanceHistoryItem(record: PendingAttendance) {
    val (statusColor, statusText) = when (record.status) {
        "VERIFIED" -> Color(0xFF1B5E20) to "Verified" // Dark Green
        "SYNCED" -> Color(0xFF1B5E20) to "Verified" // Dark Green (Treat Synced as Verified)
        "PENDING" -> Color(0xFFE65100) to "Pending Sync" // Dark Orange
        "SYNCING" -> Color(0xFF0D47A1) to "Syncing..." // Dark Blue
        else -> Color(0xFFB71C1C) to "Failed" // Dark Red
    }

    val instant = Instant.parse(record.created_at)
    val formatter = DateTimeFormatter.ofPattern("MMM dd, yyyy 'at' hh:mm a")
        .withZone(ZoneId.systemDefault())
    val formattedDate = formatter.format(instant)

    Box(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp)
            .clip(RoundedCornerShape(8.dp))
            .background(MaterialTheme.colorScheme.surfaceContainerLowest)
            .padding(12.dp)
    ) {
        Row(
            modifier = Modifier.fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Column(modifier = Modifier.weight(1f)) {
                // --- START FIX: Use className ---
                Text(
                    text = record.className,
                    style = MaterialTheme.typography.bodyMedium,
                    fontWeight = FontWeight.Bold
                )
                // --- END FIX ---
                Text(
                    text = formattedDate,
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
            Text(
                text = statusText,
                style = MaterialTheme.typography.bodyMedium,
                color = statusColor,
                fontWeight = FontWeight.Bold
            )
        }
    }
}

--- FILE: app/src/main/java/com/markme/app/ui/MainViewModel.kt ---

package com.markme.app.ui

import android.content.Context
import android.location.Location
import android.util.Base64
import android.util.Log
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import androidx.work.*
import com.markme.app.auth.EnrollmentManager
import com.markme.app.data.DatabaseManager
import com.markme.app.network.*
import com.markme.app.sync.AttendanceWorker
import com.markme.app.util.Canonicalizer
import com.markme.app.util.LocationProvider
import com.markme.app.util.TimeSyncManager
import com.markme.data.PendingAttendance
import com.markme.data.PendingAttendanceQueries
import com.squareup.moshi.Moshi
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import retrofit2.HttpException // <-- IMPORT THIS
import java.io.IOException // <-- IMPORT THIS
import java.security.Signature
import java.util.UUID
import java.util.concurrent.TimeUnit
import app.cash.sqldelight.coroutines.asFlow
import app.cash.sqldelight.coroutines.mapToList

data class HomeUiState(
    val userMessage: String? = "Initializing...",
    val isLoading: Boolean = true,
    val isMarking: Boolean = false,
    val currentSession: SessionInfoResponse? = null,
    val attendanceHistory: List<PendingAttendance> = emptyList()
)

class MainViewModel : ViewModel() {

    private val _uiState = MutableStateFlow(HomeUiState())
    val uiState = _uiState.asStateFlow()

    private lateinit var api: ApiService
    private lateinit var dbQueries: PendingAttendanceQueries
    private lateinit var workManager: WorkManager
    private lateinit var locationProvider: LocationProvider
    private lateinit var moshi: Moshi
    private lateinit var appContext: Context

    private var sessionToken: String? = null
    private var deviceId: String? = null
    private var tempLocation: Location? = null
    private var tempQrResponse: QrNonceResponse? = null

    fun initialize(context: Context) {
        this.appContext = context.applicationContext
        api = RetrofitClient.instance
        dbQueries = DatabaseManager.getInstance(appContext).pendingAttendanceQueries
        workManager = WorkManager.getInstance(appContext)
        locationProvider = LocationProvider(appContext)
        moshi = RetrofitClient.moshi

        val prefs = appContext.getSharedPreferences("MarkMePrefs", Context.MODE_PRIVATE)
        this.sessionToken = prefs.getString("SESSION_TOKEN", null)
        this.deviceId = prefs.getString("DEVICE_ID", null)

        if (sessionToken == null || deviceId == null) {
            _uiState.update { it.copy(isLoading = false, userMessage = "FATAL: Not authenticated.") }
            return
        }

        // Load Pending History from DB
        viewModelScope.launch {
            dbQueries.getAllPending().asFlow().mapToList(Dispatchers.IO).collectLatest { history ->
                _uiState.update { it.copy(attendanceHistory = history) }
            }
        }

        viewModelScope.launch {
            _uiState.update { it.copy(userMessage = "Syncing time...") }
            // Try to sync time, but don't block if offline
            try {
                TimeSyncManager.syncWithServer(api)
            } catch (e: Exception) {
                Log.w("MainViewModel", "Time sync failed (likely offline)")
            }
            fetchCurrentSession(showLoading = true)
        }
    }

    fun retryFetchSession() {
        fetchCurrentSession(showLoading = true)
    }

    private fun fetchCurrentSession(showLoading: Boolean) = viewModelScope.launch(Dispatchers.IO) {
        if (sessionToken == null) return@launch

        if (showLoading) {
            _uiState.update { it.copy(isLoading = true, userMessage = "Fetching class info...") }
        }

        try {
            val sessionInfo = api.getCurrentSession("Bearer $sessionToken")

            _uiState.update {
                it.copy(
                    userMessage = "Ready to mark for ${sessionInfo.className}",
                    isLoading = false,
                    currentSession = sessionInfo
                )
            }
            startPeriodicSync()

        } catch (e: HttpException) {
            // Server responded, but with an error (e.g., 404 Not Found)
            if (e.code() == 404) {
                _uiState.update {
                    it.copy(
                        userMessage = "No class scheduled right now.",
                        isLoading = false,
                        currentSession = null
                    )
                }
            } else {
                _uiState.update {
                    it.copy(
                        userMessage = "Server Error: ${e.message()}",
                        isLoading = false,
                        currentSession = null
                    )
                }
            }
        } catch (e: IOException) {
            // Network error (No internet, timeout) -> ENABLE OFFLINE MODE
            Log.w("MainViewModel", "Network error fetching session", e)
            _uiState.update {
                it.copy(
                    userMessage = "Offline Mode: Tap 'Mark Attendance' to scan QR.",
                    isLoading = false,
                    currentSession = null
                )
            }
        } catch (e: Exception) {
            Log.e("MainViewModel", "Unexpected error", e)
            _uiState.update {
                it.copy(
                    userMessage = "Error: ${e.message}",
                    isLoading = false,
                    currentSession = null
                )
            }
        }
    }

    fun onMarkAttendanceClicked() {
        if (_uiState.value.isMarking) return

        viewModelScope.launch(Dispatchers.IO) {
            _uiState.update { it.copy(userMessage = "Requesting location...", isMarking = true) }
            try {
                val location = locationProvider.getCurrentLocation()
                tempLocation = location
                _uiState.update {
                    it.copy(
                        userMessage = "Show teacher: ${location.latitude.format(6)}, ${location.longitude.format(6)}"
                    )
                }

            } catch (e: SecurityException) {
                _uiState.update { it.copy(userMessage = "Error: Location permission is required.", isMarking = false) }
            } catch (e: Exception) {
                _uiState.update { it.copy(userMessage = "Error: Could not get location. ${e.message}", isMarking = false) }
            }
        }
    }

    fun onScanQrClicked() {
        _uiState.update { it.copy(userMessage = "Please scan the QR code") }
    }

    fun onQrCodeScanned(qrData: String?) {
        if (qrData.isNullOrBlank()) {
            _uiState.update { it.copy(userMessage = "QR scan cancelled.", isMarking = false) }
            return
        }

        try {
            val adapter = moshi.adapter(QrNonceResponse::class.java)
            val qrNonceResponse = adapter.fromJson(qrData)

            if (qrNonceResponse == null) {
                _uiState.update { it.copy(userMessage = "Error: Invalid QR code.", isMarking = false) }
                return
            }

            // ONLINE CHECK: If we have a session, ensure QR matches it
            val currentSess = _uiState.value.currentSession
            if (currentSess != null && qrNonceResponse.sessionId != currentSess.sessionId) {
                _uiState.update { it.copy(userMessage = "Error: This QR code is for a different class.", isMarking = false) }
                return
            }

            // OFFLINE MODE: We don't have currentSess, so we trust the QR code for now.

            tempQrResponse = qrNonceResponse
            _uiState.update {
                it.copy(
                    userMessage = "QR Code Scanned. Tap 'Sign' to confirm.",
                    isMarking = true
                )
            }

        } catch (e: Exception) {
            Log.e("MainViewModel", "QR parse error", e)
            _uiState.update { it.copy(userMessage = "Error: Failed to read QR code. ${e.message}", isMarking = false) }
        }
    }

    fun onSignClicked(activity: AppCompatActivity) {
        viewModelScope.launch(Dispatchers.IO) {
            val location = tempLocation
            val qrResponse = tempQrResponse

            if (location == null || qrResponse == null) {
                _uiState.update { it.copy(userMessage = "Error: Missing data. Please start over.", isMarking = false) }
                return@launch
            }

            val hasAlreadyMarked = _uiState.value.attendanceHistory
                .any { it.sess == qrResponse.sessionId && it.status != "FAILED" }

            if (hasAlreadyMarked) {
                _uiState.update { it.copy(userMessage = "You have already marked attendance for this class.", isMarking = false) }
                return@launch
            }

            // If offline, we might not know the class name, so use a placeholder or date
            val className = _uiState.value.currentSession?.className ?: "Offline Class (${qrResponse.ts.take(10)})"

            _uiState.update { it.copy(userMessage = "Waiting for biometrics...") }

            withContext(Dispatchers.Main) {
                val onSignSuccess: (Signature) -> Unit = { unlockedSignature ->
                    createAndQueueRecord(unlockedSignature, qrResponse, location, className)
                }
                val onSignFailure: (String) -> Unit = { errorMsg ->
                    _uiState.update { it.copy(userMessage = errorMsg, isMarking = false) }
                }
                EnrollmentManager.promptForBiometricSignature(activity, onSignSuccess, onSignFailure)
            }
        }
    }

    private fun createAndQueueRecord(
        unlockedSignature: Signature,
        qr: QrNonceResponse,
        location: Location,
        className: String
    ) {
        viewModelScope.launch(Dispatchers.IO) {
            try {
                val blob = createAttendanceBlob(qr, location)
                val canonicalJson = Canonicalizer.canonicalize(blob)
                val dataToSign = canonicalJson.toByteArray(Charsets.UTF_8)

                unlockedSignature.update(dataToSign)
                val sigBytes = unlockedSignature.sign()
                val sigBase64 = Base64.encodeToString(sigBytes, Base64.NO_WRAP)

                dbQueries.insert(
                    id = blob["idempotency_key"] as String,
                    student_id = "deprecated",
                    device_id = blob["device_id"] as String,
                    sess = blob["sess"] as String,
                    qrNonce = blob["qrNonce"] as String,
                    lat = blob["lat"] as Double,
                    lon = blob["lon"] as Double,
                    className = className,
                    ts_client = blob["ts_client"] as String,
                    attendance_blob = canonicalJson,
                    student_sig = sigBase64,
                    created_at = TimeSyncManager.nowIsoUtcString()
                )

                _uiState.update {
                    it.copy(
                        userMessage = "SUCCESS! Attendance queued locally.",
                        isMarking = false
                    )
                }
                triggerOneTimeSync()

            } catch (e: Exception) {
                Log.e("MainViewModel", "Signing or DB error", e)
                _uiState.update { it.copy(userMessage = "Error during signing: ${e.message}", isMarking = false) }
            }
        }
    }

    private fun createAttendanceBlob(qr: QrNonceResponse, location: Location): Map<String, Any> {
        return mapOf(
            "ts_client" to TimeSyncManager.nowIsoUtcString(),
            "device_id" to deviceId!!,
            "sess" to qr.sessionId,
            "qrNonce" to qr.qrNonce,
            "idempotency_key" to UUID.randomUUID().toString(),
            "lat" to location.latitude.format(6).toDouble(),
            "lon" to location.longitude.format(6).toDouble()
        )
    }

    private fun Double.format(digits: Int): String = "%.${digits}f".format(this)

    private fun startPeriodicSync() {
        val constraints = Constraints.Builder().setRequiredNetworkType(NetworkType.CONNECTED).build()
        val workRequest = PeriodicWorkRequestBuilder<AttendanceWorker>(15, TimeUnit.MINUTES)
            .setConstraints(constraints)
            .setInputData(Data.Builder().putString(AttendanceWorker.INPUT_AUTH_TOKEN, sessionToken).build())
            .build()
        workManager.enqueueUniquePeriodicWork("periodic-attendance-sync", ExistingPeriodicWorkPolicy.KEEP, workRequest)
    }

    private fun triggerOneTimeSync() {
        val constraints = Constraints.Builder().setRequiredNetworkType(NetworkType.CONNECTED).build()
        val workRequest = OneTimeWorkRequestBuilder<AttendanceWorker>()
            .setConstraints(constraints)
            .setInputData(Data.Builder().putString(AttendanceWorker.INPUT_AUTH_TOKEN, sessionToken).build())
            .build()
        workManager.enqueue(workRequest)
    }
}

--- FILE: app/src/main/java/com/markme/app/ui/theme/Color.kt ---

package com.markme.app.ui.theme

import androidx.compose.ui.graphics.Color

val Purple80 = Color(0xFFD0BCFF)
val PurpleGrey80 = Color(0xFFCCC2DC)
val Pink80 = Color(0xFFEFB8C8)

val Purple40 = Color(0xFF6650a4)
val PurpleGrey40 = Color(0xFF625b71)
val Pink40 = Color(0xFF7D5260)

--- FILE: app/src/main/java/com/markme/app/ui/theme/Theme.kt ---

package com.markme.app.ui.theme

import android.app.Activity
import android.os.Build
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.dynamicDarkColorScheme
import androidx.compose.material3.dynamicLightColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.ui.platform.LocalContext

private val DarkColorScheme = darkColorScheme(
    primary = Purple80,
    secondary = PurpleGrey80,
    tertiary = Pink80
)

private val LightColorScheme = lightColorScheme(
    primary = Purple40,
    secondary = PurpleGrey40,
    tertiary = Pink40

    /* Other default colors to override
    background = Color(0xFFFFFBFE),
    surface = Color(0xFFFFFBFE),
    onPrimary = Color.White,
    onSecondary = Color.White,
    onTertiary = Color.White,
    onBackground = Color(0xFF1C1B1F),
    onSurface = Color(0xFF1C1B1F),
    */
)

@Composable
fun ProjectMarkMeTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    // Dynamic color is available on Android 12+
    dynamicColor: Boolean = true,
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
            val context = LocalContext.current
            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
        }

        darkTheme -> DarkColorScheme
        else -> LightColorScheme
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
}

--- FILE: app/src/main/java/com/markme/app/ui/theme/Type.kt ---

package com.markme.app.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

// Set of Material typography styles to start with
val Typography = Typography(
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp
    )
    /* Other default text styles to override
    titleLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 22.sp,
        lineHeight = 28.sp,
        letterSpacing = 0.sp
    ),
    labelSmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 11.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp
    )
    */
)

--- FILE: app/src/main/java/com/markme/app/util/Canonicalizer.kt ---

package com.markme.app.util

import org.json.JSONArray
import org.json.JSONObject

/**
 * Deterministic JSON canonicalizer.
 * This logic MUST be byte-for-byte identical to the server's implementation.
 *
 * Rules:
 * 1. Sort object keys alphabetically.
 * 2. Do not sort array elements.
 * 3. Serialize to a compact string (no whitespace).
 */
object Canonicalizer {

    fun canonicalize(data: Map<String, Any>): String {
        return canonicalizeMap(data)
    }

    private fun canonicalizeValue(value: Any?): String {
        return when (value) {
            null -> "null"
            is String -> JSONObject.quote(value) // Use JSONObject just for string quoting
            is Boolean, is Number -> value.toString()
            is Map<*, *> -> canonicalizeMap(value as Map<String, Any>)
            is List<*> -> canonicalizeList(value as List<Any>)
            // Fallback for other types
            else -> JSONObject.quote(value.toString())
        }
    }

    private fun canonicalizeMap(map: Map<String, Any>): String {
        // Sort keys alphabetically, just like the server
        val sortedKeys = map.keys.sorted()

        // Manually build the string to guarantee order
        return sortedKeys.joinToString(
            separator = ",",
            prefix = "{",
            postfix = "}"
        ) { key ->
            // "key":"value"
            "${JSONObject.quote(key)}:${canonicalizeValue(map[key])}"
        }
    }

    private fun canonicalizeList(list: List<Any>): String {
        // Arrays are not sorted, just processed in order
        return list.joinToString(
            separator = ",",
            prefix = "[",
            postfix = "]"
        ) { value ->
            canonicalizeValue(value)
        }
    }
}

--- FILE: app/src/main/java/com/markme/app/util/LocationProvider.kt ---

package com.markme.app.util

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.location.Location
import android.util.Log
import androidx.core.content.ContextCompat
import com.google.android.gms.location.LocationServices
import com.google.android.gms.location.Priority
import com.google.android.gms.tasks.CancellationTokenSource
import kotlinx.coroutines.suspendCancellableCoroutine // <-- This provides the function
import kotlin.coroutines.resume
import kotlin.coroutines.resumeWithException

class LocationProvider(private val context: Context) {

    private val fusedLocationClient = LocationServices.getFusedLocationProviderClient(context)
    private val TAG = "LocationProvider"

    fun hasLocationPermission(): Boolean {
        return ContextCompat.checkSelfPermission(
            context,
            Manifest.permission.ACCESS_FINE_LOCATION
        ) == PackageManager.PERMISSION_GRANTED
    }

    /**
     * Gets a single, high-accuracy location update.
     * This is a suspend function that wraps the callback-based API.
     */
    suspend fun getCurrentLocation(): Location = suspendCancellableCoroutine { continuation ->
        if (!hasLocationPermission()) {
            continuation.resumeWithException(SecurityException("Missing location permission"))
            return@suspendCancellableCoroutine
        }

        val cancellationToken = CancellationTokenSource()

        fusedLocationClient.getCurrentLocation(
            Priority.PRIORITY_HIGH_ACCURACY,
            cancellationToken.token
        ).addOnSuccessListener { location: Location? ->
            if (location != null) {
                // Check if the coroutine is still active before resuming
                if (continuation.isActive) {
                    Log.i(TAG, "Got location: ${location.latitude}, ${location.longitude}")
                    continuation.resume(location)
                }
            } else {
                if (continuation.isActive) {
                    Log.w(TAG, "Failed to get location, result was null.")
                    continuation.resumeWithException(Exception("Failed to get location (null)"))
                }
            }
        }.addOnFailureListener { e ->
            if (continuation.isActive) {
                Log.e(TAG, "Failed to get location", e)
                continuation.resumeWithException(e)
            }
        }

        // This is the function that was unresolved.
        // It's a method on the 'continuation' object.
        continuation.invokeOnCancellation {
            cancellationToken.cancel()
        }
    }
}

--- FILE: app/src/main/java/com/markme/app/util/TimeSyncManager.kt ---

package com.markme.app.util

import android.util.Log
import com.markme.app.network.ApiService
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.time.Instant
import java.util.concurrent.atomic.AtomicLong

object TimeSyncManager {

    private const val TAG = "TimeSyncManager"
    private var offsetMs = AtomicLong(0L)

    // We will call this from our main activity or viewmodel
    suspend fun syncWithServer(api: ApiService) = withContext(Dispatchers.IO) {
        try {
            val localBefore = System.currentTimeMillis()
            val serverResponse = api.getServerTime()
            val localAfter = System.currentTimeMillis()

            // Estimate network latency
            val latency = (localAfter - localBefore) / 2

            val serverTime = Instant.parse(serverResponse.utc).toEpochMilli()
            val adjustedServerTime = serverTime + latency

            val localNow = System.currentTimeMillis()

            val newOffset = adjustedServerTime - localNow
            offsetMs.set(newOffset)

            Log.i(TAG, "Time sync successful. Offset: ${newOffset}ms")

        } catch (e: Exception) {
            Log.e(TAG, "Time sync failed: ${e.message}")
            // We'll keep using the old offset (or 0)
        }
    }

    /**
     * Returns the current, trusted UTC time in milliseconds.
     */
    fun nowUtcMillis(): Long {
        return System.currentTimeMillis() + offsetMs.get()
    }

    /**
     * Returns the current, trusted UTC time as an ISO 8601 string.
     * This is what we will put in our JSON blobs.
     */
    fun nowIsoUtcString(): String {
        return Instant.ofEpochMilli(nowUtcMillis()).toString()
    }
}

--- FILE: app/src/main/res/drawable/ic_launcher_background.xml ---

<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <path
        android:fillColor="#3DDC84"
        android:pathData="M0,0h108v108h-108z" />
    <path
        android:fillColor="#00000000"
        android:pathData="M9,0L9,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,0L19,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,0L29,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,0L39,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,0L49,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,0L59,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,0L69,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,0L79,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M89,0L89,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M99,0L99,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,9L108,9"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,19L108,19"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,29L108,29"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,39L108,39"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,49L108,49"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,59L108,59"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,69L108,69"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,79L108,79"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,89L108,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,99L108,99"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,29L89,29"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,39L89,39"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,49L89,49"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,59L89,59"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,69L89,69"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,79L89,79"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,19L29,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,19L39,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,19L49,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,19L59,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,19L69,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,19L79,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
</vector>


--- FILE: app/src/main/res/drawable/ic_launcher_foreground.xml ---

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <path android:pathData="M31,63.928c0,0 6.4,-11 12.1,-13.1c7.2,-2.6 26,-1.4 26,-1.4l38.1,38.1L107,108.928l-32,-1L31,63.928z">
        <aapt:attr name="android:fillColor">
            <gradient
                android:endX="85.84757"
                android:endY="92.4963"
                android:startX="42.9492"
                android:startY="49.59793"
                android:type="linear">
                <item
                    android:color="#44000000"
                    android:offset="0.0" />
                <item
                    android:color="#00000000"
                    android:offset="1.0" />
            </gradient>
        </aapt:attr>
    </path>
    <path
        android:fillColor="#FFFFFF"
        android:fillType="nonZero"
        android:pathData="M65.3,45.828l3.8,-6.6c0.2,-0.4 0.1,-0.9 -0.3,-1.1c-0.4,-0.2 -0.9,-0.1 -1.1,0.3l-3.9,6.7c-6.3,-2.8 -13.4,-2.8 -19.7,0l-3.9,-6.7c-0.2,-0.4 -0.7,-0.5 -1.1,-0.3C38.8,38.328 38.7,38.828 38.9,39.228l3.8,6.6C36.2,49.428 31.7,56.028 31,63.928h46C76.3,56.028 71.8,49.428 65.3,45.828zM43.4,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2c-0.3,-0.7 -0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C45.3,56.528 44.5,57.328 43.4,57.328L43.4,57.328zM64.6,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2s-0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C66.5,56.528 65.6,57.328 64.6,57.328L64.6,57.328z"
        android:strokeWidth="1"
        android:strokeColor="#00000000" />
</vector>

--- FILE: app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml ---

<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/ic_launcher_background"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>

--- FILE: app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml ---

<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/ic_launcher_background"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>

--- FILE: app/src/main/res/values/colors.xml ---

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="purple_200">#FFBB86FC</color>
    <color name="purple_500">#FF6200EE</color>
    <color name="purple_700">#FF3700B3</color>
    <color name="teal_200">#FF03DAC5</color>
    <color name="teal_700">#FF018786</color>
    <color name="black">#FF000000</color>
    <color name="white">#FFFFFFFF</color>
</resources>

--- FILE: app/src/main/res/values/ic_launcher_background.xml ---

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="ic_launcher_background">#FFFFFF</color>
</resources>

--- FILE: app/src/main/res/values/strings.xml ---

<resources>
    <string name="app_name">Mark Me</string>
</resources>

--- FILE: app/src/main/res/values/themes.xml ---

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- MODIFIED: Inherit from a Material Components theme -->
    <style name="Theme.ProjectMarkMe" parent="Theme.Material3.DayNight.NoActionBar">
        <!-- Customize your theme here. -->
        <!-- For example, primary colors etc. -->
        <!-- <item name="colorPrimary">@color/purple_500</item> -->
        <!-- <item name="colorPrimaryVariant">@color/purple_700</item> -->
        <!-- <item name="colorOnPrimary">@color/white</item> -->
        <!-- Secondary -->
        <!-- <item name="colorSecondary">@color/teal_200</item> -->
        <!-- <item name="colorSecondaryVariant">@color/teal_700</item> -->
        <!-- <item name="colorOnSecondary">@color/black</item> -->
        <!-- Status bar color -->
        <!-- <item name="android:statusBarColor">?attr/colorPrimaryVariant</item> -->
    </style>
</resources>

--- FILE: app/src/main/res/xml/backup_rules.xml ---

<?xml version="1.0" encoding="utf-8"?><!--
   Sample backup rules file; uncomment and customize as necessary.
   See https://developer.android.com/guide/topics/data/autobackup
   for details.
   Note: This file is ignored for devices older than API 31
   See https://developer.android.com/about/versions/12/backup-restore
-->
<full-backup-content>
    <!--
   <include domain="sharedpref" path="."/>
   <exclude domain="sharedpref" path="device.xml"/>
-->
</full-backup-content>

--- FILE: app/src/main/res/xml/data_extraction_rules.xml ---

<?xml version="1.0" encoding="utf-8"?><!--
   Sample data extraction rules file; uncomment and customize as necessary.
   See https://developer.android.com/about/versions/12/backup-restore#xml-changes
   for details.
-->
<data-extraction-rules>
    <cloud-backup>
        <!-- TODO: Use <include> and <exclude> to control what is backed up.
        <include .../>
        <exclude .../>
        -->
    </cloud-backup>
    <!--
    <device-transfer>
        <include .../>
        <exclude .../>
    </device-transfer>
    -->
</data-extraction-rules>

--- FILE: app/src/main/res/xml/network_security_config.xml ---

<?xml version="1.0" encoding="utf-8"?>
<network-security-config>

    <domain-config cleartextTrafficPermitted="true">
        <domain includeSubdomains="true">192.168.137.1</domain> </domain-config>

    <domain-config>
        <domain includeSubdomains="true">kangaroo-ultimate-correctly.ngrok-free.app</domain>
    </domain-config>
    <base-config cleartextTrafficPermitted="false" />
</network-security-config>

--- FILE: app/src/main/sqldelight/com/markme/data/PendingAttendance.sq ---

CREATE TABLE PendingAttendance (
    id TEXT NOT NULL PRIMARY KEY, -- This is the idempotency_key
    student_id TEXT NOT NULL,
    device_id TEXT NOT NULL,
    sess TEXT NOT NULL,

    qrNonce TEXT NOT NULL,
    lat REAL NOT NULL,
    lon REAL NOT NULL,

    className TEXT NOT NULL DEFAULT 'Unknown Class',

    ts_client TEXT NOT NULL,
    attendance_blob TEXT NOT NULL, -- The full canonical JSON blob that was signed
    student_sig TEXT NOT NULL,     -- The base64 signature
    status TEXT NOT NULL DEFAULT 'PENDING', -- PENDING, SYNCING, SYNCED, FAILED
    attempts INTEGER NOT NULL DEFAULT 0,
    created_at TEXT NOT NULL
);

-- --- NEW TABLES FOR OFFLINE SUPPORT ---

-- Table for Verified History (Synced records + Records fetched from server)
CREATE TABLE VerifiedAttendance (
    id TEXT NOT NULL PRIMARY KEY,
    sessionId TEXT NOT NULL,
    className TEXT NOT NULL,
    status TEXT NOT NULL,
    timestamp TEXT NOT NULL, -- ISO 8601
    subjectId TEXT -- Optional, useful for filtering by subject offline
);

-- Table for User Data / Timetable
CREATE TABLE CachedSubject (
    id TEXT NOT NULL PRIMARY KEY,
    code TEXT NOT NULL,
    name TEXT NOT NULL
);

-- --- EXISTING QUERIES ---

getPending:
SELECT * FROM PendingAttendance
WHERE status = 'PENDING' OR (status = 'FAILED' AND attempts < 5)
ORDER BY created_at ASC
LIMIT :limit;

getById:
SELECT * FROM PendingAttendance WHERE id = ?;

getAllPending:
SELECT * FROM PendingAttendance
ORDER BY created_at DESC;

insert:
INSERT INTO PendingAttendance(
    id, student_id, device_id, sess,
    qrNonce, lat, lon,
    className,
    ts_client, attendance_blob, student_sig, created_at,
    status, attempts
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'PENDING', 0);

markAsSyncing:
UPDATE PendingAttendance
SET status = 'SYNCING', attempts = attempts + 1
WHERE id IN ?;

markAsFailed:
UPDATE PendingAttendance
SET status = 'FAILED'
WHERE id IN ?;

deleteById:
DELETE FROM PendingAttendance
WHERE id = ?;

-- --- NEW QUERIES FOR OFFLINE SUPPORT ---

-- Verified Attendance Queries
getAllVerified:
SELECT * FROM VerifiedAttendance
ORDER BY timestamp DESC;

getVerifiedBySubject:
SELECT * FROM VerifiedAttendance
WHERE subjectId = ?
ORDER BY timestamp DESC;

insertVerified:
INSERT OR REPLACE INTO VerifiedAttendance(id, sessionId, className, status, timestamp, subjectId)
VALUES (?, ?, ?, ?, ?, ?);

-- Cached Subject Queries
getAllSubjects:
SELECT * FROM CachedSubject
ORDER BY name ASC;

insertSubject:
INSERT OR REPLACE INTO CachedSubject(id, code, name)
VALUES (?, ?, ?);

deleteAllSubjects:
DELETE FROM CachedSubject;

--- FILE: app/src/test/java/com/markme/app/ExampleUnitTest.kt ---

package com.markme.app

import org.junit.Test

import org.junit.Assert.*

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
class ExampleUnitTest {
    @Test
    fun addition_isCorrect() {
        assertEquals(4, 2 + 2)
    }
}

--- FILE: gradle/libs.versions.toml ---

[versions]
# --- CORE PLUGINS ---
agp = "8.2.0"
kotlin = "1.9.23"
kotlinComposeCompiler = "1.5.11"
sqldelight = "2.0.2"
navigationCompose = "2.7.7"
materialIconsExtended = "1.6.8"

# --- CORE LIBRARIES ---
coreKtx = "1.12.0"
activityCompose = "1.9.3"
composeBom = "2024.02.01"
lifecycleRuntimeKtx = "2.7.0"
appcompat = "1.7.0"
material = "1.12.0"

# --- OUR PROJECT LIBRARIES ---
retrofit = "2.9.0"
moshi = "1.14.0"
okhttp = "4.11.0"
workmanager = "2.9.0"
biometric = "1.2.0-alpha05"
securityCrypto = "1.0.0"
playServicesAuth = "21.0.0"
lifecycleViewmodel = "2.7.0"

# --- START NEW VERSIONS ---
playServicesLocation = "21.3.0"
zxing = "4.3.0"
kotlinxCoroutines = "1.8.0"
# --- END NEW VERSIONS ---

# --- TESTING ---
junit = "4.13.2"
androidxJunit = "1.1.5"
espressoCore = "3.5.1"

[libraries]
# --- CORE ANDROID & COMPOSE ---
androidx-core-ktx = { group = "androidx.core", name = "core-ktx", version.ref = "coreKtx" }
androidx-lifecycle-runtime-ktx = { group = "androidx.lifecycle", name = "lifecycle-runtime-ktx", version.ref = "lifecycleRuntimeKtx" }
androidx-activity-compose = { group = "androidx.activity", name = "activity-compose", version.ref = "activityCompose" }
androidx-compose-bom = { group = "androidx.compose", name = "compose-bom", version.ref = "composeBom" }
androidx-ui = { group = "androidx.compose.ui", name = "ui" }
androidx-ui-graphics = { group = "androidx.compose.ui", name = "ui-graphics" }
androidx-ui-tooling-preview = { group = "androidx.compose.ui", name = "ui-tooling-preview" }
androidx-material3 = { group = "androidx.compose.material3", name = "material3" }
androidx-appcompat = { group = "androidx.appcompat", name = "appcompat", version.ref = "appcompat" }
google-material = { group = "com.google.android.material", name = "material", version.ref = "material" }

# --- OUR PROJECT LIBRARIES ---
retrofit-main = { group = "com.squareup.retrofit2", name = "retrofit", version.ref = "retrofit" }
retrofit-converter-moshi = { group = "com.squareup.retrofit2", name = "converter-moshi", version.ref = "retrofit" }
okhttp-main = { group = "com.squareup.okhttp3", name = "okhttp", version.ref = "okhttp" }
okhttp-logging-interceptor = { group = "com.squareup.okhttp3", name = "logging-interceptor", version.ref = "okhttp" }
moshi-kotlin = { group = "com.squareup.moshi", name = "moshi-kotlin", version.ref = "moshi" }
androidx-workmanager = { group = "androidx.work", name = "work-runtime-ktx", version.ref = "workmanager" }
androidx-biometric = { group = "androidx.biometric", name = "biometric", version.ref = "biometric" }
androidx-security-crypto = { group = "androidx.security", name = "security-crypto", version.ref = "securityCrypto" }
play-services-auth = { group = "com.google.android.gms", name = "play-services-auth", version.ref = "playServicesAuth" }
androidx-lifecycle-viewmodel-compose = { group = "androidx.lifecycle", name = "lifecycle-viewmodel-compose", version.ref = "lifecycleViewmodel" }
androidx-navigation-compose = { group = "androidx.navigation", name = "navigation-compose", version.ref = "navigationCompose" }
androidx-material-icons-extended = { group = "androidx.compose.material", name = "material-icons-extended", version.ref = "materialIconsExtended" }

# --- START NEW LIBRARIES ---
kotlinx-coroutines-android = { group = "org.jetbrains.kotlinx", name = "kotlinx-coroutines-android", version.ref = "kotlinxCoroutines" }
play-services-location = { group = "com.google.android.gms", name = "play-services-location", version.ref = "playServicesLocation" }
zxing-android-embedded = { group = "com.journeyapps", name = "zxing-android-embedded", version.ref = "zxing" }
# --- END NEW LIBRARIES ---

# --- SQLDELIGHT ---
sqldelight-android-driver = { group = "app.cash.sqldelight", name = "android-driver", version.ref = "sqldelight" }
sqldelight-coroutines = { group = "app.cash.sqldelight", name = "coroutines-extensions", version.ref = "sqldelight" }

# --- TESTING ---
junit = { group = "junit", name = "junit", version.ref = "junit" }
androidx-junit = { group = "androidx.test.ext", name = "junit", version.ref = "androidxJunit" }
androidx-espresso-core = { group = "androidx.test.espresso", name = "espresso-core", version.ref = "espressoCore" }
androidx-ui-test-junit4 = { group = "androidx.compose.ui", name = "ui-test-junit4" }
androidx-ui-tooling = { group = "androidx.compose.ui", name = "ui-tooling" }
androidx-ui-test-manifest = { group = "androidx.compose.ui", name = "ui-test-manifest" }

[plugins]
android-application = { id = "com.android.application", version.ref = "agp" }
kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }
sqldelight = { id = "app.cash.sqldelight", version.ref = "sqldelight" }

--- FILE: gradle/wrapper/gradle-wrapper.properties ---

#Thu Nov 13 00:09:18 IST 2025
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.13-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
